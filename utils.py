from collections import Counter
from itertools import product
from os import listdir
import numpy as np

INSTR_SET = {'mov', 'xchg', 'stc', 'clc', 'cmc', 'std', 'cld', 'sti', 'cli', 'push', 'pushf', 'pusha',
             'pop', 'popf', 'popa', 'ccombw', 'cwd', 'cwde', 'in', 'out', 'add', 'adc', 'sub', 'sbb',
             'div', 'idiv', 'mul', 'imul', 'inc', 'dec', 'cmp', 'sal', 'sar', 'rcl', 'rcr', 'rol', 'ror',
             'neg', 'not', 'and', 'or', 'xor', 'shl', 'shr', 'nop', 'lea', 'int', 'call', 'jmp', 'je',
             'jz', 'jcxz', 'jp', 'jpe', 'ja', 'jae', 'jb', 'jbe', 'jna', 'jnae', 'jnb', 'jnbe', 'jc',
             'jnc', 'ret', 'jne', 'jnz', 'jecxz', 'jnp', 'jpo', 'jg', 'jge', 'jl', 'jle', 'jng', 'jnge', 'jnl',
             'jnle', 'jo', 'jno', 'js', 'jns'}

# instr2i = {instr: i for i, instr in enumerate(i2instr)}
# INSTR_SET = set(i2instr)
# i2NGRAM_DICT = {}
# NGRAM2i_DICT = {}

UNKNOWN = "unk"
i2ngram = [UNKNOWN]
ngram2i = {UNKNOWN: 0}


def get_opcodes_from_asm_file(file_name):
    opcodes = []
    for line in file(file_name):
        if not line.startswith(".text"):
            continue
        line = line.split()
        if len(line) < 3:  # no opcode
            continue
        for s in line[1:]:
            if s in INSTR_SET:
                opcodes.append(s)
                break
            elif s == ';':
                break
    return opcodes


# def make_ngrams_dict_for_n(n):
#     i2NGRAM_DICT[n] = list(product(xrange(len(INSTR_SET)), repeat=n))
#
#     def get_index_by_ngram(ngram):
#         l = len(INSTR_SET)
#         n = len(ngram)
#         index = 0
#         for i, x in enumerate(ngram):
#             index += x * (l ** (n - i - 1))
#         return index
#
#     NGRAM2i_DICT[n] = get_index_by_ngram


def make_ngrams(opcodes, n):
    return [tuple(instrs[i:i+n]) for instrs in opcodes for i in xrange(len(instrs) - n)]


# def make_ngrams_counters(lst, n):
#     if n not in i2NGRAM_DICT:
#         make_ngrams_dict_for_n(n)
#     i2ngrams = i2NGRAM_DICT[n]  # ngram list
#     ngram2i = NGRAM2i_DICT[n]  # function that maps ngram to it's index in above list
#
#     counters = [0] * len(i2NGRAM_DICT[n])
#     for i in xrange(0, len(lst) - n):
#         ngram = tuple(lst[i:i + n])
#         counters[ngram2i(ngram)] += 1
#     return counters


# def get_file_features(file_name, ns):
#     opcodes = get_opcodes_from_asm_file(file_name)
#     counters = []
#     for n in sorted(ns):  # go over ngrams in order of n
#         counters += make_ngrams_counters(opcodes, n)
#     return counters
#
#
# def get_features_of_all_asm_files_in_folder(path_to_folder, ns):
#     files = listdir(path_to_folder)
#     features = None
#     for f in files:
#         if f.endswith(".asm"):
#
#             array = np.array(get_file_features(path_to_folder + "/" + f, ns))
#             if features is not None:
#                 features = np.vstack((features, array))
#             else:
#                 features = array
#             pass
#     return features


def get_all_possible_ngrams_from_files(ngrams_lists, ns, use_unknown=True, unknown_precent=0.01):
    """

    :param ngrams_lists:
    :type ngrams_lists: dict
    :param ns:
    :return:
    """
    ngrams_lists = {n: [ngram for f in l for ngram in f] for n, l in ngrams_lists}
    ngrams_sets = {n: set(l) for n, l in ngrams_lists}

    if use_unknown:
        counters = Counter([ngram for n in ns for ngram in ngrams_lists[n]])
        not_used = counters.most_common()[:-unknown_precent * len(counters) - 1:-1]
        for ngram in not_used:
            n = len(ngram)
            ngrams_sets[n].discard(ngram)

    i2ngram = [ngram for n in sorted(list(ngrams_sets.keys())) for ngram in sorted(list(ngrams_sets[n]))]
    if use_unknown:
        i2ngram.append(UNKNOWN)
    ngram2i = {ngram: i for i, ngram in enumerate(i2ngram)}
    return ngrams_sets, i2ngram, ngram2i


def make_ngram_counters_for_files(ngrams_lists, ngram_sets, i2ngram, ngram2i, ns, use_unknown=True):
    """

    :param ngrams_lists: dictionary that maps n to a list of ngram tuples from files (each file is a list)
    :param i2ngram:
    :param ngram2i:
    :param opcodes:
    :param ngram_sets:
    :type ngram_sets: dict
    :param ns:
    :param use_unknown:
    :param unknown_precent:
    :return:
    """
    num_files = len(ngrams_lists[ns[0]])
    features = []
    for i in xrange(num_files):
        file_features = [0] * len(i2ngram)
        for n in ns:
            for ngram in ngrams_lists[n][i]:
                index = ngram2i[ngram] if not use_unknown or ngram in ngram_sets[n] else ngram2i[UNKNOWN]
                file_features[index] += 1
        features.append(file_features)
    return features


def get_all_files_features_and_labels(path_to_folder, ns, use_unknown=True, unknown_rate=0.01):
    files = listdir(path_to_folder)
    ngrams_list = {n: [] for n in ns}
    labels = []  # TODO FIND LABELS FOR FILES
    for f in files:
        if f.endswith(".asm"):
            opcodes = get_opcodes_from_asm_file(path_to_folder + "/" + f)
            for n in ns:
                ngrams_list[n].append(make_ngrams(opcodes, n))

    # now we have a dictionary that maps from an n to a list of ngram partition for each file

    ngrams_sets, i2ngram, ngram2i = get_all_possible_ngrams_from_files(ngrams_list, ns, use_unknown, unknown_rate)
    features = make_ngram_counters_for_files(ngrams_list, ngrams_sets, i2ngram, ngram2i, ns, use_unknown)

    return features, labels, ngrams_sets, i2ngram, ngram2i


# tests of utils functions
if __name__ == '__main__':
    x, y, sets, i2n, n2i = get_all_files_features_and_labels("./files/train50", [4])
    print len(i2n)
    print x[0]
    print y[0]
    pass
